# Plan 10: Hybrid Search & Reranking (PRD Module 6)

⚠️ **Complexity: Medium** - Requires database changes, new service integration, and algorithm implementation

## Overview

Currently, the system uses **vector search only** for document retrieval. This module adds:
1. **Keyword search** (PostgreSQL full-text search) for exact term matching
2. **Hybrid search** combining vector + keyword using RRF (Reciprocal Rank Fusion)
3. **Reranking** using a cross-encoder model to reorder results by relevance

**Why?** Vector search alone misses exact keyword matches and struggles with technical terms, acronyms, and proper nouns. Hybrid search + reranking provides the best of both worlds.

---

## Learning Goals

- Understand limitations of pure vector search
- Learn full-text search with PostgreSQL (tsvector, ts_rank)
- Implement Reciprocal Rank Fusion (RRF) algorithm
- Integrate reranking via cross-encoder models
- Balance precision and recall in retrieval

---

## Architecture Changes

### Current Flow
```
User Query → Embed Query → Vector Search (match_chunks) → Return Top-K
```

### New Flow
```
User Query → [Parallel Execution]
              ├─ Embed Query → Vector Search
              └─ Keyword Search (full-text)
            → RRF Combine Results
            → Rerank Top-N
            → Return Best Results
```

---

## Tasks

### Task 1: Add Full-Text Search to Database Schema

**Files:**
- `supabase/migrations/20260214210000_add_fulltext_search.sql` (NEW)
- `backend/migrations/005_add_fulltext_search.sql` (NEW)

**Migration Steps:**
1. Add `content_tsv` tsvector column to `chunks` table
2. Create GIN index on `content_tsv` for fast full-text search
3. Create trigger to automatically update `content_tsv` when content changes
4. Create `keyword_search_chunks` function for full-text search
5. Backfill `content_tsv` for existing chunks

**SQL Example:**
```sql
-- Add tsvector column for full-text search
ALTER TABLE chunks ADD COLUMN content_tsv tsvector
  GENERATED ALWAYS AS (to_tsvector('english', content)) STORED;

-- Create GIN index for fast full-text search
CREATE INDEX idx_chunks_content_tsv ON chunks USING GIN (content_tsv);

-- Keyword search function
CREATE OR REPLACE FUNCTION keyword_search_chunks(
    query_text text,
    match_count int,
    p_user_id uuid,
    metadata_filters jsonb DEFAULT NULL
) RETURNS TABLE (
    id uuid,
    document_id uuid,
    content text,
    chunk_index int,
    metadata jsonb,
    rank float
) LANGUAGE plpgsql AS $$
BEGIN
    RETURN QUERY
    SELECT c.id, c.document_id, c.content, c.chunk_index, c.metadata,
           ts_rank(c.content_tsv, websearch_to_tsquery('english', query_text)) AS rank
    FROM chunks c
    WHERE c.user_id = p_user_id
      AND c.content_tsv @@ websearch_to_tsquery('english', query_text)
      AND (metadata_filters IS NULL OR c.metadata @> metadata_filters)
    ORDER BY rank DESC
    LIMIT match_count;
END;
$$;
```

**Validation:**
- Verify tsvector column populated for all chunks
- Test keyword search function returns relevant results
- Verify GIN index is being used (EXPLAIN ANALYZE)

---

### Task 2: Create Hybrid Search Function with RRF

**Files:**
- `supabase/migrations/20260214210000_add_fulltext_search.sql` (UPDATE)

**Implementation:**
Create `hybrid_search_chunks` function that:
1. Executes vector search (calls `match_chunks`)
2. Executes keyword search (calls `keyword_search_chunks`)
3. Combines results using Reciprocal Rank Fusion (RRF)
4. Returns merged, ranked results

**RRF Algorithm:**
```
RRF_score(item) = Σ 1 / (k + rank_i)
where:
  k = 60 (constant to reduce impact of high ranks)
  rank_i = rank of item in search method i
```

**SQL Example:**
```sql
CREATE OR REPLACE FUNCTION hybrid_search_chunks(
    query_text text,
    query_embedding vector(1536),
    match_threshold float DEFAULT 0.5,
    match_count int DEFAULT 20,
    final_count int DEFAULT 5,
    p_user_id uuid DEFAULT NULL,
    metadata_filters jsonb DEFAULT NULL,
    rrf_k int DEFAULT 60
) RETURNS TABLE (
    id uuid,
    document_id uuid,
    content text,
    chunk_index int,
    metadata jsonb,
    vector_similarity float,
    keyword_rank float,
    rrf_score float
) LANGUAGE plpgsql AS $$
BEGIN
    RETURN QUERY
    WITH vector_results AS (
        SELECT v.id, v.similarity,
               ROW_NUMBER() OVER (ORDER BY v.similarity DESC) as rank
        FROM match_chunks(query_embedding, match_threshold, match_count, p_user_id, metadata_filters) v
    ),
    keyword_results AS (
        SELECT k.id, k.rank,
               ROW_NUMBER() OVER (ORDER BY k.rank DESC) as rank_position
        FROM keyword_search_chunks(query_text, match_count, p_user_id, metadata_filters) k
    ),
    combined AS (
        SELECT
            COALESCE(v.id, k.id) as id,
            COALESCE(v.similarity, 0) as vector_similarity,
            COALESCE(k.rank, 0) as keyword_rank,
            (COALESCE(1.0 / (rrf_k + v.rank), 0) +
             COALESCE(1.0 / (rrf_k + k.rank_position), 0)) as rrf_score
        FROM vector_results v
        FULL OUTER JOIN keyword_results k ON v.id = k.id
    )
    SELECT c.id, c.document_id, c.content, c.chunk_index, c.metadata,
           combined.vector_similarity, combined.keyword_rank, combined.rrf_score
    FROM combined
    JOIN chunks c ON c.id = combined.id
    ORDER BY combined.rrf_score DESC
    LIMIT final_count;
END;
$$;
```

**Validation:**
- Test with queries that benefit from keyword search (e.g., "FastAPI")
- Test with semantic queries (e.g., "how to handle errors")
- Verify results include both exact matches and semantic matches
- Confirm RRF scores are calculated correctly

---

### Task 3: Add Reranker Service

**Files:**
- `backend/app/services/reranker_service.py` (NEW)
- `backend/app/models/schemas.py` (UPDATE)
- `backend/requirements.txt` (UPDATE)

**Approach:**
Use **Jina AI Reranker API** (free tier available) or **Cohere Rerank API**.

**Installation:**
```txt
# For Jina AI
requests>=2.31.0  # Already installed

# Alternative: Cohere
# cohere>=4.0.0
```

**Implementation:**
```python
"""Reranking service using Jina AI Reranker API."""
import os
from typing import List
import httpx

JINA_API_KEY = os.getenv("JINA_API_KEY", "")
JINA_RERANK_MODEL = os.getenv("JINA_RERANK_MODEL", "jina-reranker-v2-base-multilingual")
JINA_RERANK_ENABLED = os.getenv("JINA_RERANK_ENABLED", "false").lower() == "true"


async def rerank_chunks(
    query: str,
    chunks: List[dict],
    top_n: int = 5
) -> List[dict]:
    """
    Rerank chunks using Jina AI Reranker API.

    Args:
        query: User query
        chunks: List of chunks from hybrid search (must have 'content' field)
        top_n: Number of top results to return after reranking

    Returns:
        Reranked list of chunks with 'rerank_score' added
    """
    if not JINA_RERANK_ENABLED or not JINA_API_KEY:
        # Return original chunks if reranking disabled
        return chunks[:top_n]

    if not chunks:
        return []

    # Prepare documents for reranking
    documents = [chunk["content"] for chunk in chunks]

    # Call Jina Reranker API
    async with httpx.AsyncClient() as client:
        response = await client.post(
            "https://api.jina.ai/v1/rerank",
            headers={
                "Authorization": f"Bearer {JINA_API_KEY}",
                "Content-Type": "application/json"
            },
            json={
                "model": JINA_RERANK_MODEL,
                "query": query,
                "documents": documents,
                "top_n": top_n
            },
            timeout=30.0
        )
        response.raise_for_status()
        result = response.json()

    # Map reranked results back to original chunks
    reranked = []
    for item in result.get("results", []):
        original_index = item["index"]
        chunk = chunks[original_index].copy()
        chunk["rerank_score"] = item["relevance_score"]
        reranked.append(chunk)

    return reranked
```

**Schema Updates:**
```python
# Add to backend/app/models/schemas.py
class GlobalSettings(BaseModel):
    # ... existing fields

    # Reranker settings
    jina_api_key: str | None = None
    jina_rerank_model: str = "jina-reranker-v2-base-multilingual"
    jina_rerank_enabled: bool = False
```

**Validation:**
- Test with JINA_RERANK_ENABLED=false (should skip reranking)
- Test with JINA_RERANK_ENABLED=true and valid API key
- Verify reranked results have higher relevance than RRF-only results
- Test error handling (invalid API key, timeout)

---

### Task 4: Update Retrieval Service for Hybrid Search

**Files:**
- `backend/app/services/retrieval_service.py` (UPDATE)
- `backend/app/db/supabase.py` (UPDATE if needed for new RPC call)

**Implementation:**
Update `search_documents` function to:
1. Call `hybrid_search_chunks` RPC instead of `match_chunks`
2. Pass both query text and query embedding
3. Call reranker service on results
4. Return final reranked results

**Code:**
```python
"""Hybrid search with optional reranking."""
from app.db.supabase import get_supabase_client
from app.services.embedding_service import get_embeddings
from app.services.reranker_service import rerank_chunks


async def search_documents(
    query: str,
    user_id: str,
    top_k: int = 5,
    threshold: float = 0.5,
    metadata_filters: dict | None = None,
    use_reranking: bool = True
) -> list[dict]:
    """
    Search user's documents using hybrid search (vector + keyword) with optional reranking.

    Args:
        query: Search query text
        user_id: User ID for RLS filtering
        top_k: Number of final results to return
        threshold: Minimum similarity threshold for vector search
        metadata_filters: Optional metadata filters
        use_reranking: Whether to apply reranking (default True)

    Returns:
        List of reranked chunks with relevance scores
    """
    # Get query embedding for vector search
    query_embedding = await get_embeddings([query], user_id=user_id)

    # Call hybrid search RPC (combines vector + keyword + RRF)
    supabase = get_supabase_client()
    rpc_params = {
        "query_text": query,
        "query_embedding": query_embedding[0],
        "match_threshold": threshold,
        "match_count": 20,  # Retrieve more candidates for reranking
        "final_count": 15,  # Return top 15 from RRF for reranking
        "p_user_id": user_id,
        "metadata_filters": metadata_filters,
        "rrf_k": 60
    }

    result = supabase.rpc("hybrid_search_chunks", rpc_params).execute()
    chunks = result.data or []

    if not chunks:
        return []

    # Apply reranking if enabled
    if use_reranking:
        chunks = await rerank_chunks(query, chunks, top_n=top_k)
    else:
        chunks = chunks[:top_k]

    return chunks
```

**Validation:**
- Test hybrid search returns better results than vector-only
- Test with reranking enabled and disabled
- Verify metadata_filters still work correctly
- Test edge cases (empty query, no results, API errors)

---

### Task 5: Update Global Settings for Reranker

**Files:**
- `backend/app/routers/settings.py` (UPDATE)
- `frontend/src/components/settings/SettingsPage.tsx` (UPDATE)
- `backend/.env.example` (UPDATE)

**Backend `.env.example`:**
```bash
# Reranker Configuration (Jina AI)
JINA_API_KEY=your_jina_api_key_here
JINA_RERANK_MODEL=jina-reranker-v2-base-multilingual
JINA_RERANK_ENABLED=true
```

**Frontend Settings UI:**
Add new section in SettingsPage.tsx:
```tsx
{/* Reranker Configuration */}
<div className="space-y-4">
  <h3 className="text-lg font-medium">Reranker Configuration</h3>
  <div className="space-y-2">
    <Label htmlFor="jina_api_key">Jina API Key</Label>
    <Input
      id="jina_api_key"
      value={settings.jina_api_key || ''}
      onChange={(e) => setSettings({...settings, jina_api_key: e.target.value})}
      placeholder="jina_..."
    />
  </div>
  <div className="space-y-2">
    <Label htmlFor="jina_rerank_model">Reranker Model</Label>
    <Input
      id="jina_rerank_model"
      value={settings.jina_rerank_model || 'jina-reranker-v2-base-multilingual'}
      onChange={(e) => setSettings({...settings, jina_rerank_model: e.target.value})}
    />
  </div>
  <div className="flex items-center space-x-2">
    <input
      type="checkbox"
      id="jina_rerank_enabled"
      checked={settings.jina_rerank_enabled || false}
      onChange={(e) => setSettings({...settings, jina_rerank_enabled: e.target.checked})}
    />
    <Label htmlFor="jina_rerank_enabled">Enable Reranking</Label>
  </div>
</div>
```

**Validation:**
- Verify settings can be saved and retrieved
- Test API key masking for Jina API key
- Verify reranking toggle works (enable/disable)

---

### Task 6: Update RAG Tool Definition

**Files:**
- `backend/app/services/llm_service.py` (UPDATE)

**Update `search_documents` tool description:**
```python
RAG_TOOLS = [
    {
        "type": "function",
        "function": {
            "name": "search_documents",
            "description": """Search the user's uploaded documents using hybrid search (vector + keyword) with reranking.

            Hybrid search combines semantic similarity (vector) with exact keyword matching (full-text).
            Results are automatically reranked by a cross-encoder model for maximum relevance.

            Use this when the user asks questions that could be answered by their uploaded documents.
            Examples: technical questions, how-to queries, factual lookups, code examples.

            The search supports metadata filtering for precise results.
            """,
            "parameters": {
                "type": "object",
                "properties": {
                    "query": {
                        "type": "string",
                        "description": "Search query (semantic or keyword-based)"
                    },
                    "metadata_filters": {
                        # ... existing metadata_filters schema
                    }
                },
                "required": ["query"]
            }
        }
    }
]
```

**Validation:**
- Test LLM uses updated tool description correctly
- Verify tool calls include appropriate queries

---

### Task 7: Add Comparison Tests to Validation Suite

**Files:**
- `.agent/validation/full-suite.md` (UPDATE)
- `.agent/validation/fixtures/hybrid_search_test.txt` (NEW)

**Create Test Document:**
Create `.agent/validation/fixtures/hybrid_search_test.txt`:
```
FastAPI Configuration Guide

This document explains how to configure FastAPI applications for production deployment.

## Environment Variables
FastAPI applications use environment variables for configuration:
- DATABASE_URL: PostgreSQL connection string
- REDIS_URL: Redis connection string for caching
- API_KEY: Authentication key

## CORS Configuration
Configure CORS middleware to allow requests from your frontend:
```python
from fastapi.middleware.cors import CORSMiddleware
app.add_middleware(CORSMiddleware, allow_origins=["*"])
```

## Database Connection Pooling
Use SQLAlchemy with proper connection pool settings:
- pool_size: 10
- max_overflow: 20
- pool_timeout: 30
```

**Add Tests:**
- **API-52**: Upload hybrid search test document
- **API-53**: Vector-only search for "FastAPI" (should find semantic matches)
- **API-54**: Keyword search for "CORS" (should find exact term)
- **API-55**: Hybrid search for "database configuration" (should combine both)
- **E2E-31**: Chat asks "How to configure CORS in FastAPI?" and verify citation

**Validation:**
Compare results from:
1. Vector-only search
2. Keyword-only search
3. Hybrid (RRF) search
4. Hybrid + reranking

Expect hybrid + reranking to perform best overall.

---

### Task 8: Update PROGRESS.md and Documentation

**Files:**
- `PROGRESS.md` (UPDATE)
- `CLAUDE.md` (UPDATE if needed)
- `.agent/plans/10.hybrid-search-reranking.md` (this file)

**PROGRESS.md Updates:**
```markdown
### Module 7: Hybrid Search & Reranking (PRD Module 6)
- [ ] Add Full-Text Search to Database Schema
- [ ] Create Hybrid Search Function with RRF
- [ ] Add Reranker Service (Jina AI)
- [ ] Update Retrieval Service for Hybrid Search
- [ ] Update Global Settings for Reranker
- [ ] Update RAG Tool Definition
- [ ] Add Comparison Tests to Validation Suite
- [ ] Update PROGRESS.md and Documentation

**Status: NOT STARTED**
```

**Documentation:**
Add notes about:
- Full-text search capabilities
- RRF algorithm and tuning (rrf_k parameter)
- Reranker model choice and trade-offs
- When to use keyword vs semantic search
- Cost implications (Jina API calls)

---

## Success Criteria

- ✅ Full-text search available via `keyword_search_chunks` function
- ✅ Hybrid search combines vector + keyword with RRF
- ✅ Reranker service integrated with Jina AI API
- ✅ Settings UI allows configuring reranker
- ✅ Retrieval uses hybrid search + reranking by default
- ✅ Validation tests show improved relevance vs vector-only
- ✅ All tests pass (API-52 to API-55, E2E-31)
- ✅ Documentation updated with new capabilities
- ✅ Backend restarts successfully with new code

---

## Dependencies

- PostgreSQL 14+ with pgvector extension (already installed)
- Jina AI API account (free tier: https://jina.ai/reranker)
- No new Python packages required (uses httpx, already installed)

---

## Complexity Assessment

**⚠️ Medium Complexity:**
- Database function writing (SQL complexity)
- RRF algorithm implementation
- API integration (Jina AI)
- Balancing parameters (thresholds, top_k, rrf_k)

**Time Estimate:** 2-3 hours with careful testing

**Risk Areas:**
- SQL function syntax errors
- RRF score calculation bugs
- Reranker API rate limits or errors
- Performance degradation from two searches

**Mitigation:**
- Test SQL functions in Supabase SQL Editor first
- Add comprehensive error handling
- Make reranking optional (fallback to RRF-only)
- Monitor query performance with EXPLAIN ANALYZE

---

## Notes

- **Why RRF?** It's simple, effective, and doesn't require training. Reciprocal rank naturally balances different scoring scales.
- **Why Jina AI?** Free tier, good performance, simple REST API. Alternative: Cohere Rerank (more expensive but potentially better).
- **Tuning:** Start with rrf_k=60 (standard). Increase for more democratic fusion, decrease to favor top-ranked items.
- **Cost:** Jina free tier: 10k API calls/month. Each chat message = 1 rerank call. Monitor usage in production.
- **Future:** Consider caching reranked results for common queries.
